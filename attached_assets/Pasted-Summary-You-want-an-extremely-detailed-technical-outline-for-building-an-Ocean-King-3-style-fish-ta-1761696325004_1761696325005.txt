Summary: You want an extremely detailed technical outline for building an Ocean King 3 style fish table game. You want C#. You want to support 8 concurrent online players in real time. You want the design tuned for fast pace, synchronized shooting, and responsive hit resolution. You will hand this outline to an AI codegen agent.

Below is the outline. It is structured for implementation. It covers core systems, networking model, performance strategy, anti-cheat, and extensibility.

Section 1. High level game concept
1.1 Core loop
	•	Up to 8 players join the same arena instance.
	•	Dozens of fish move across the screen with unique movement patterns and values.
	•	Players fire continuously at targets using virtual cannons.
	•	Each bullet fired consumes credits.
	•	When a fish is killed, the killing player is awarded credits based on fish type and a configurable payout multiplier.
	•	Timed bonus events spawn high value targets or special weapons.

1.2 Session style
	•	Continuous session. No traditional round end.
	•	Players can join and leave without interrupting others.
	•	Server keeps the room “always on” until empty.

1.3 Business logic layer
	•	Strong authoritative server logic. Clients are treated as untrusted.

1.4 Technical pillars
	•	Deterministic fish state and HP managed by server.
	•	Low latency shooting feedback for client feel.
	•	Predictive client effects, server-corrected truth.

Section 2. Tech stack assumptions
2.1 Language
	•	C# 12 or latest stable at code time.

2.2 Runtime targets
	•	Server: .NET 8 Kestrel headless service.
	•	Client: Unity for rendering and input, also in C#. (If you are not using Unity, substitute MonoGame or Stride. The networking and game state model stays the same.)

2.3 Networking
	•	Realtime UDP-like transport preferred for action channels.
	•	Reliable TCP/WebSocket channel for lobby, economy, and critical events.
	•	If Replit can only scaffold WebSockets, treat WebSocket as transport and implement lightweight unreliable lanes via sequence numbers and drop tolerance.

2.4 Database
	•	In-memory state per match. Persist only meter data (credits in/out) and audit logs to durable storage.
	•	Redis or similar for lobby/matchmaking and balance sync if you scale to multiple instances.

Section 3. Core server architecture
3.1 Process layout
	•	GameServerHost
	•	MatchManager
	•	MatchInstance[matchId]
	•	PlayerManager
	•	FishManager
	•	ProjectileManager
	•	CollisionResolver
	•	PayoutProcessor
	•	EventScheduler
	•	Networking layer
	•	IncomingCommandQueue
	•	OutgoingStateBroadcaster

3.2 Threading model
Option A (simple and good enough for 8 players):
	•	One dedicated game loop thread per MatchInstance.
	•	Tick rate target: 30 to 60 ticks per second. 30 TPS is lower CPU, 60 TPS feels smoother.
	•	Networking IO handled async and enqueued into thread-safe queues consumed by the loop.

Why:
	•	Single-threaded game loop per match avoids race conditions on fish HP, hit detection, payouts.
	•	8 players × 1 room is trivial CPU load for .NET on modern hardware at 60 TPS.

3.3 Main loop (per MatchInstance)
Pseudocode steps each tick:
	1.	Read all pending player inputs from IncomingCommandQueue.
	2.	Apply inputs (shoot requests, weapon changes).
	3.	Advance fish movement.
	4.	Advance projectiles.
	5.	Run collision checks.
	6.	Resolve kills, compute payouts.
	7.	Spawn new fish if needed.
	8.	Run timed bonus events.
	9.	Build StateDelta message.
	10.	Broadcast StateDelta to all connected clients.

Section 4. Networking protocol
4.1 Player -> Server messages
	•	JoinMatch
	•	playerId
	•	authToken
	•	InputFire
	•	sequenceId
	•	timestampClient
	•	shotOrigin (x,y)
	•	shotDirection (angle or normalized vector)
	•	weaponType
	•	ChangeWeapon
	•	weaponType
	•	RequestSkill / Bomb / LightningChain
	•	abilityId
	•	Heartbeat
	•	pingMsEstimate

4.2 Server -> Player messages
	•	MatchSnapshot (on join or resync)
	•	list of fish {id, type, hp, position, velocity, value}
	•	list of players {id, name, credits, cannonLevel}
	•	currentEvents (bonuses active)
	•	StateDelta (each tick or every N ticks)
	•	updated fish positions
	•	fish spawns/despawns
	•	projectile spawns
	•	hit confirmations
	•	credit changes
	•	KillEvent
	•	fishId
	•	killedByPlayerId
	•	payoutAmount
	•	BonusEventStart / BonusEventEnd
	•	SystemMessage (insufficient credits etc.)

4.3 Reliability strategy
	•	Each message carries serverTickId.
	•	Client stores last acknowledgedTickId.
	•	Server can resend last K StateDeltas if client misses packets.
	•	Critical economy results (credit balance) are redundantly sent on reliable channel and require client ACK.

4.4 Latency hiding
	•	Client spawns muzzle flash and projectile trail locally on click with no wait.
	•	Server is authoritative for whether projectile actually exists and what it hits.
	•	On correction:
	•	If server denies a shot (e.g. no credits), client rolls back projectile and shows “no credit” pulse.
	•	If server says projectile hit different fish than client predicted, client snaps to server truth.

Section 5. Matchmaking and session management
5.1 Lobby service
	•	PublicRooms list holds up to N concurrent matches.
	•	Each MatchInstance has metadata:
	•	matchId
	•	occupancyCount / maxPlayers (8)
	•	avgPayoutRate (for analytics)
	•	isLocked (maintenance or VIP etc.)

5.2 Join flow
	1.	Client requests “JoinAnyOpen”.
	2.	Lobby picks match with <8 players or spawns new MatchInstance.
	3.	Lobby returns matchId and server endpoint.
	4.	Client opens realtime socket directly to match’s server thread.

5.3 Leave flow
	•	Client sends LeaveMatch or disconnects.
	•	Server:
	•	marks player slot free
	•	stops broadcasting state to them
	•	persists final credit balance if needed

5.4 Empty-room cleanup
	•	If playerCount == 0 for >X seconds, MatchInstance shuts down.

Section 6. Entity systems
6.1 Fish entity
Fields:
	•	fishId
	•	typeId
	•	hp
	•	maxHp
	•	baseValue
	•	position (x,y)
	•	velocity (vx,vy)
	•	hitboxRadius or polygon
	•	movementPatternId
	•	spawnTimestampTick
	•	despawnTimeoutTick
	•	specialFlags (explosive, chainLightningEligible etc.)

Behavior:
	•	MovementPattern is deterministic function(timeSinceSpawn). Example: Sine wave, spiral, slow tank boss, fast darting minnow.
	•	HP decreases when hit.
	•	When hp <= 0
	•	mark for removal
	•	enqueue KillEvent

Spawn control:
	•	FishManager maintains targetDifficultyBudget and targetCount.
	•	Ensures visual density stays high but CPU safe.

6.2 Projectile entity
Fields:
	•	projId
	•	ownerPlayerId
	•	weaponTypeId
	•	position (x,y)
	•	direction (dx,dy normalized)
	•	speed
	•	damage
	•	ttlTicks

Behavior per tick:
	•	position += direction * speed * deltaTime
	•	Decrement ttl.
	•	If ttl < 0 mark remove.

6.3 Player entity (server side)
Fields:
	•	playerId
	•	displayName
	•	credits
	•	cannonLevel / weaponType
	•	position/orientation of cannon
	•	fireRateLimiterState (to block macro spam above server caps)
	•	latencyEstimateMs
	•	connectedSocketRef

Section 7. Combat flow and payouts
7.1 Fire request validation
Steps when InputFire arrives:
	1.	Check player credits >= weaponCost.
	2.	Check fire rate limit for that player.
	3.	Deduct provisional cost immediately from player credits.
	4.	Spawn projectile in ProjectileManager owned by that player.

Why provisional:
	•	You must deduct immediately server side for anti-cheat.
	•	If later the projectile never hits anything you keep the spend. That matches typical Ocean King 3 style devices.

7.2 Collision resolution
	•	Each tick:
	•	For each projectile P:
	•	For each fish F in range:
	•	If distance(P.position, F.position) <= F.hitboxRadius:
	•	Apply damage.
	•	Mark projectile spent.
	•	Break.

Note: naive O(projectiles * fishCount) might be fine for 8 players if you cap entities (for example 60 fish and <200 active projectiles). If scaling higher, add spatial partitioning.

7.3 Kill and payout
When fish HP <= 0:
	1.	Determine killing projectile (and thus killer playerId).
	2.	Compute payout:
	•	baseValue * randomMultiplierTable[typeId]
	•	Example multiplier table: [1x,2x,3x,5x,10x] with rarity weights per fish type.
	3.	Add payout to killer credits.
	4.	Emit KillEvent to all players so they see explosions and who won.

7.4 Anti-inflation and tuning levers
	•	Adjust baseValue per fish type.
	•	Adjust HP per fish type.
	•	Adjust multiplier table distribution.
These knobs control RTP (return to player) and perceived excitement. High HP + high value boss = spectacle kill moment. Low HP + low value swarm = constant dopamine ticks.

Section 8. Bonus / special events
8.1 Timed waves
	•	Every N seconds spawn “Crazy Crab Wave” or “Golden Dragon Boss”.
	•	EventScheduler pushes an EventStart message.
	•	FishManager spawns scripted patterns for duration.

8.2 Special weapons
	•	Lightning Chain
	•	Player triggers.
	•	Server picks random nearby fish and arcs chain damage across up to K fish.
	•	High burst payout moment.
	•	Bomb / Nuke
	•	AoE damage in radius.
	•	Expensive to fire.
	•	Good comeback mechanic.

8.3 Jackpot / Metered bonus (if desired)
	•	Global shared meter that increments with every shot spent.
	•	Rarely triggers “Jackpot Fish” worth very high payout.
	•	If you include any wager-like mechanic you have legal exposure in many jurisdictions. This statement is factual and relevant. Laws differ by state in the US and country by country. You are responsible for compliance.

Section 9. Client architecture (Unity-style C#)
9.1 Core systems
	•	NetworkClient
	•	Send input commands.
	•	Receive state updates.
	•	Interpolate/extrapolate fish motion.
	•	RenderSystem
	•	Draw fish sprites / skeletal animations.
	•	Draw cannons and bullet VFX.
	•	Draw hit flashes, explosions, payout numbers.
	•	UI/HUD
	•	Credit count.
	•	Player list / seat indicators 1..8.
	•	Active bonus timers.
	•	Big text callouts for Boss Spawn, Jackpot Win, etc.

9.2 Prediction model
	•	On local fire:
	•	Deduct provisional credit in HUD.
	•	Spawn local visual projectile immediately.
	•	On server update:
	•	Reconcile:
	•	Snap projectile if server disagrees.
	•	Snap credit if correction occurs.

9.3 Interpolation / smoothing
	•	Fish positions from server may be sparse (30 or 60 TPS snapshots).
	•	Client stores last two known states for each fish and interpolates.
	•	If packet loss causes gap > threshold, client extrapolates velocity briefly.
	•	When server sends corrected position, client lerps back over ~100 ms to hide pop.

Section 10. Performance and scalability strategy
10.1 Tick rate and work budget
	•	Target TPS: 60.
	•	Budget per tick: 16 ms total to keep real time feel.
	•	Physics + AI + payout + broadcast.
	•	8 players is small so CPU headroom is high. The biggest load is broadcast bandwidth.

10.2 Bandwidth control
	•	Use compact binary serialization for StateDelta.
	•	Send only deltas:
	•	Fish that changed position significantly.
	•	Fish that spawned or died.
	•	Projectiles spawned this tick.
	•	Throttle cosmetic spam. For example do not send sparkle particles. Let client generate local particles on KillEvent.

10.3 Spatial partitioning (future scaling)
	•	If fish count > ~100 you will need acceleration structures.
	•	Use uniform grid partitioning:
	•	Divide arena into cells.
	•	Each tick only test projectile vs fish in same or adjacent cells.
	•	Data structure: Dictionary<(int cellX,int cellY), List>.

10.4 GC pressure in C#
	•	Avoid per-tick allocations inside the main loop.
	•	Use object pools for Projectiles and Fish.
	•	Reuse List buffers for network packets.
	•	This is important in .NET 8 to prevent LOH churn and random GC spikes that cause hitching.

Section 11. Concurrency and synchronization
11.1 Single-writer rule
	•	All authoritative simulation state (fish HP, player credits) is mutated only in the MatchInstance loop thread.
	•	Network layer pushes messages into a ConcurrentQueue.
	•	The loop consumes and applies them. No other thread mutates world state.

11.2 Outbound updates
	•	After each tick the loop writes a StateDelta snapshot into a ring buffer.
	•	A separate async sender task reads that buffer and dispatches to sockets.
	•	The sender task never mutates gameplay state. It only reads immutable snapshots.

Why this matters:
	•	You get deterministic simulation.
	•	You eliminate lock contention.
	•	You reduce desync bugs.

Section 12. Anti cheat and fairness
12.1 Credit spend
	•	Server validates credit balance before every shot.
	•	Server, not client, decrements credits.

12.2 Fire rate / auto clickers
	•	Track lastFireTick per player.
	•	If InputFire arrives faster than allowed weapon fireRate, discard and optionally flag.

12.3 Position spoofing
	•	Client can claim cannon angle or position. Server may trust cannon angle but should clamp fire origin to that player’s allowed seat zone.

12.4 Tampered hit scans
	•	Clients never say “I hit fish X.”
	•	Clients only say “I fired a bullet at angle A at time T.”
	•	Server simulates bullet and decides hits.

12.5 Latency exploits
	•	Each InputFire holds client timestamp. Server can compare to arrival tick to estimate RTT and clamp how far back in time it will retroactively simulate. This stops “lag switch headshots.”

Section 13. Extensibility hooks
13.1 Config-driven fish tables
	•	Keep fish types and movement patterns in external JSON or ScriptableObjects.
	•	hp
	•	baseValue
	•	speed
	•	hitboxRadius
	•	spawnWeight
	•	allowedDuringEvents[]

This lets you add new fish without code change.

13.2 Weapon tuning table
	•	Cannon level N:
	•	projectileSpeed
	•	damage
	•	costPerShot
	•	fireRate
Expose as editable data so you can rebalance without redeploy.

13.3 Event scripts
	•	EventScheduler reads small state machines or timelines from config files.
	•	Example:
	•	t=0 spawn “King Crab” at path “circle_middle”
	•	t=5 spawn “SwarmShrimp” 20x at path “zigzag_low”
	•	t=10 broadcast BonusEventEnd

13.4 Economy backend
	•	Optional external service records:
	•	playerId
	•	creditsIn
	•	creditsOut
	•	timestamp
Used for analytics and compliance.

Section 14. Data models (suggested C# classes / records)
14.1 Fish

public class Fish {
    public int Id;
    public int TypeId;
    public float Hp;
    public float MaxHp;
    public float BaseValue;
    public Vector2 Position;
    public Vector2 Velocity;
    public float HitboxRadius;
    public int MovementPatternId;
    public int SpawnTick;
    public int DespawnTick;
    public FishFlags Flags;
}

14.2 PlayerState

public class PlayerState {
    public int PlayerId;
    public string Name;
    public int Credits;
    public int WeaponTypeId;
    public float CannonAngleDeg;
    public FireLimiter FireLimiter;
    public bool Connected;
}

14.3 Projectile

public class Projectile {
    public int Id;
    public int OwnerPlayerId;
    public int WeaponTypeId;
    public Vector2 Position;
    public Vector2 Direction;
    public float Speed;
    public float Damage;
    public int TtlTicks;
}

14.4 InboundCommand

public struct InboundCommand {
    public int PlayerId;
    public CommandType Type;
    public InputFireData FireData;
    public long ClientTimestampMs;
    public int SequenceId;
}

14.5 StateDelta payload (server -> client)

public class StateDelta {
    public int ServerTick;
    public List<FishUpdate> FishUpdates;
    public List<int> FishDespawnIds;
    public List<FishSpawn> FishSpawns;
    public List<ProjectileSpawn> ProjectileSpawns;
    public List<KillNotice> KillNotices;
    public List<PlayerCreditUpdate> CreditUpdates;
}

Section 15. Core algorithms the AI should implement
15.1 Game loop timing
	•	Fixed timestep loop:
	•	Accumulate elapsed real time.
	•	Run Update() at fixed dt (e.g. 1/60 second).
	•	Sleep/yield if ahead to avoid 100 percent CPU spin.

15.2 Movement patterns
	•	Implement IMovementPattern interface:

public interface IMovementPattern {
    Vector2 GetPositionAtTime(float t);
    Vector2 GetVelocityAtTime(float t);
}

	•	Concrete patterns:
	•	StraightLinePattern
	•	SineWavePattern
	•	CircleOrbitPattern
	•	ZigZagBurstPattern
Store patternId -> pattern instance map.

15.3 Collision
	•	Start with circle hitboxes.
	•	distanceSquared <= (rFish + rProj)^2 test to avoid sqrt per check.

15.4 Interpolation on client
	•	Maintain history buffer Dictionary<int fishId, RingBuffer>.
	•	Render position = lerp between snapshots around renderTime = serverTime - interpolationDelayMs.

Section 16. Edge cases the AI must code for
16.1 Player joins mid chaos
	•	New player needs a full MatchSnapshot so their client is synced before first delta.
	•	Until ACK from client, server should not allow that player to fire. Prevents shooting from stale state.

16.2 Player disconnects during payout
	•	Credits from KillEvent caused by that player still must be added to their account record on server before they are fully removed.

16.3 Projectiles after fish despawn
	•	If fish already removed, projectile just continues or expires. No payout duplication.

16.4 Bonus event overlap
	•	EventScheduler must prevent two exclusive global events from running at the same time unless explicitly allowed by design.

16.5 Floating point drift
	•	Server is authoritative so drift mainly matters client side.
	•	Client reconciliation logic must snap hard if error distance > threshold.

Section 17. Deliverables you should request the codegen system to generate
17.1 Server solution
	•	.NET 8 console or ASP.NET Core project called OceanServer
	•	/Networking
	•	ConnectionHandler.cs
	•	MessageSerializer.cs
	•	/GameLoop
	•	MatchManager.cs
	•	MatchInstance.cs
	•	TickTimer.cs
	•	/Entities
	•	Fish.cs
	•	PlayerState.cs
	•	Projectile.cs
	•	/Systems
	•	FishManager.cs
	•	ProjectileManager.cs
	•	CollisionResolver.cs
	•	PayoutProcessor.cs
	•	EventScheduler.cs
	•	/Protocol
	•	ClientToServerMessages.cs
	•	ServerToClientMessages.cs
	•	StateDelta.cs
	•	/Config
	•	FishTypes.json
	•	Weapons.json
	•	Events.json

17.2 Client solution
	•	Unity project OceanClient
	•	/Scripts/Network
	•	NetClient.cs
	•	MessageParser.cs
	•	InterpolationBuffer.cs
	•	/Scripts/Game
	•	FishController.cs
	•	ProjectileController.cs
	•	CannonController.cs
	•	LocalInputController.cs
	•	CreditDisplayController.cs
	•	KillFeedUI.cs
	•	/Scripts/FX
	•	ExplosionVFXPool.cs
	•	FloatingTextPool.cs
	•	/Assets/Config
	•	Sprites / fish
	•	Sprites / cannons
	•	Audio / sfx_fire
	•	Audio / sfx_explosion
	•	UI prefabs

17.3 Simulation test harness
	•	Headless server test that:
	•	Spawns 8 fake players.
	•	Fires random shots.
	•	Runs for 5 minutes.
	•	Logs average tick duration, bandwidth per tick, total payouts.
This gives performance baselines and RTP math.

Section 18. Priority notes for Replit
18.1 Most important feature to generate first
	•	Authoritative MatchInstance loop with:
	•	Fish spawn/move
	•	Player fire requests
	•	Projectile vs fish collision
	•	Payout and credit update
	•	StateDelta broadcast over WebSocket

This is the spine. Everything else plugs in.

18.2 Second priority
	•	Client stub that:
	•	Connects
	•	Renders fish as colored circles
	•	Lets user click to fire
	•	Shows credit count
No art required yet.

18.3 Third priority
	•	EventScheduler and special weapons
These can come after core loop is stable.

Section 19. Key performance strategies for fast paced play
19.1 Keep tick loop single threaded per match
	•	Prevents locks and keeps determinism.
	•	Ensures consistent kill resolution.

19.2 Use fixed timestep and deterministic math for fish movement server side
	•	So all clients can interpolate smoothly.

19.3 Delta compression on outgoing packets
	•	The less bandwidth, the lower the perceived lag.

19.4 Client-side prediction plus server correction
	•	Gives instant weapon response while staying cheat resistant.

19.5 Object pooling
	•	Prevents GC spikes which would create frame drops or lag bursts.

Section 20. Summary instructions for the AI code generator
Provide these instructions verbatim to the generator:
	1.	Create a .NET 8 C# authoritative realtime game server named OceanServer that supports one MatchInstance with up to 8 players.
	2.	Implement a fixed timestep game loop at 60 ticks per second in MatchInstance.
	3.	Implement FishManager, ProjectileManager, CollisionResolver, and PayoutProcessor as described above.
	4.	Accept player fire input over WebSocket. Do not trust client hit results.
	5.	Broadcast StateDelta messages with fish positions, projectiles, kills, and credit updates. Use compact C# models from Section 14.
	6.	Enforce credit spend per shot and fire rate limits server side.
	7.	Build a Unity C# client stub named OceanClient that connects, renders fish as circles, renders cannons for up to 8 seats, and sends fire commands when the local user clicks.
	8.	Add TODO comments where art, polish, or compliance systems would go.
	9.	Add a headless load test harness that simulates 8 players firing nonstop for benchmarking.

This outline gives Replit enough structure to generate first-pass code for an Ocean King 3 style multiplayer fish shooter in C#, with real time pacing, synchronized state, and up to 8 online players.